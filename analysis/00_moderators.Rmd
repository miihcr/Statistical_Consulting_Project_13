---
title: 'Research Question 2: Moderating Variables'
author: "Klavs Kalvenieks"
date: "2025-11-02"
output: pdf_document
---

```{r setup, include=FALSE}
source(here::here("scripts","_common.R"), local = knitr::knit_global())

# Function to extract key fit indices
fit_table <- function(fit) {
data.frame(
ChiSq = fitMeasures(fit, "chisq"),
df = fitMeasures(fit, "df"),
CFI = fitMeasures(fit, "cfi"),
TLI = fitMeasures(fit, "tli"),
RMSEA = fitMeasures(fit, "rmsea"),
SRMR = fitMeasures(fit, "srmr")
)
}

```

## Social susceptibility

```{r}
data <- read.csv(here::here("data","raw","data_2.csv"))

# Calculate SUS scores and check reliability
social_anxiety_items = c("SUS_1","SUS_3","SUS_5","SUS_7")
peers_self_esteem_items = c("SUS_2","SUS_4","SUS_6","SUS_8")
all_items = c("SUS_1", "SUS_2", "SUS_3", "SUS_4",
              "SUS_5", "SUS_6", "SUS_7", "SUS_8")

sus_scores = data[, grep("SUS_", names(data))]

```

### Reliability analysis (internal consistency)

#### Two factors

```{r}
social_anxiety_rel = alpha(sus_scores[social_anxiety_items], check.keys = FALSE)
alpha_value1 = social_anxiety_rel$total$raw_alpha 
alpha_value1

omega(sus_scores[social_anxiety_items])$omega.tot
```

The internal consistency of the Social Anxiety scale: Cronbach’s alpha = `r round(alpha_value1, 3)`

```{r}
self_esteem_rel = alpha(sus_scores[peers_self_esteem_items], check.keys = FALSE)
alpha_value2 = self_esteem_rel$total$raw_alpha
alpha_value2

omega(sus_scores[peers_self_esteem_items])$omega.tot
```

The internal consistency of the Self Esteem scale: Cronbach’s alpha = `r round(alpha_value2, 3)`

Seems like a good fit, test all item reliability.

#### One factor

```{r}

all_items_rel = alpha(sus_scores[all_items], check.keys = FALSE)
alpha_value3 = all_items_rel$total$raw_alpha # cronbachs alpha for total score
alpha_value3

omega(sus_scores)$omega.tot # omega for total score 
```

Also a good fit, might make sense to combine all of them together. The internal consistency of the all items: Cronbach’s alpha = `r round(alpha_value3, 3)`

### CFA

```{r}

# 1-factor model

cfa_1f <- "
  SocialSusceptibility =~ SUS_1 + SUS_2 + SUS_3 + SUS_4 + SUS_5 + SUS_6 + SUS_7 + SUS_8
"

# 2-factor model
cfa_2f <- "
  SocialAnxiety =~ SUS_1 + SUS_3 + SUS_5 + SUS_7
  PeerEsteem    =~ SUS_2 + SUS_4 + SUS_6 + SUS_8
"

fit1 <- cfa(
cfa_1f,
data = sus_scores,
std.lv = TRUE, # factor variances are set to 1 for identification
missing = "fiml" # missing value handling
)


fit2 <- cfa(
cfa_2f,
data = sus_scores,
std.lv = TRUE,
missing = "fiml"
)


summary(fit1, fit.measures = TRUE, standardized = TRUE)
summary(fit2, fit.measures = TRUE, standardized = TRUE)


# Fit measures
fit_table(fit1)
fit_table(fit2)


interpret(fit1)
interpret(fit2)

```

```{r}
# Removing item 2
cfa_minus2 <- '
  SocialSusceptibility =~ SUS_1 + SUS_3 + SUS_4 + SUS_5 + SUS_6 + SUS_7 + SUS_8
'

fit_minus2 <- cfa(
  cfa_minus2,
  data    = sus_scores,
  std.lv  = TRUE,
  missing = "fiml"
)

interpret(fit_minus2)

summary(fit_minus2, fit.measures = TRUE, standardized = TRUE)
fit_table(fit_minus2)
```

```{r}
# Removing item 4
cfa_minus4 <- '
  SocialSusceptibility =~ SUS_1 + SUS_3 + SUS_2 + SUS_5 + SUS_6 + SUS_7 + SUS_8
'

fit_minus4 <- cfa(
  cfa_minus4,
  data    = sus_scores,
  std.lv  = TRUE,
  missing = "fiml"
)

interpret(fit_minus4)

summary(fit_minus4, fit.measures = TRUE, standardized = TRUE)
fit_table(fit_minus4)
```

CFA indicates that 2-factor model is significantly better (chi-sq difference test), however the the latent variables are highly correlated (std.lv), therefore it might not make sense to use two

## Visualizing CFA models

```{r}


# Visualize the measurement model
png("figures/sem-plots/semplot_onefactor.png", width = 7, height = 5, res = 300,
    units = "in")

semPaths(fit1,         # name of fitted model object 
         what="std",      # display standardized parameter estimates
         weighted=FALSE,  # do not weight plot features
         nCharNodes=0)    # do not abbreviate names

dev.off()

# Visualize the measurement model
png("figures/sem-plots/semplot_twofactor.png", width = 7, height = 5, res = 300,
    units = "in")

semPaths(fit2,         
         what="std",      
         weighted=FALSE,  
         nCharNodes=0)    


dev.off()

# ONE FACTOR MODEL MODEL (WITHOUT ITEM 2)
png("figures/sem-plots/semplot_minus2.png", width = 7, height = 5, res = 300,
    units = "in")

semPaths(fit_minus2,       
         what="std",     
         weighted=FALSE, 
         nCharNodes=0)    

dev.off()

```

## Social Cohesion

```{r}

data$ppn      <- as.character(data$ppn)
data$class    <- as.character(data$class)
data$school   <- as.character(data$school)
data$nom_like <- as.character(data$nom_like)

data_sn <- subset(data, select = c(ppn, school, class, nom_like))

# Convert comma-separated nominations to list
data_sn$nom_like <- strsplit(data_sn$nom_like, ",")

```

```{r}
# Expand to long format
edges <- unnest(data_sn, cols = c(nom_like))

# Clean up whitespace and remove NA/empty
edges$nom_like <- str_trim(edges$nom_like)
edges <- subset(edges, nom_like != "" & !is.na(nom_like))

# Rename for clarity
colnames(edges)[colnames(edges) == "nom_like"] <- "target"
colnames(edges)[colnames(edges) == "ppn"]      <- "source"

nodes <- data_sn[, c("ppn", "school", "class")]
colnames(nodes)[1] <- "name" 

```

Not all id's are present in dataset, but they have been nominated. Check which one have to be added

### Missing id's

```{r}
classes <- sort(unique(data_sn$class))  

invalid_all <- data.frame(name = character(), class = character(), school = character())

for (c in classes) {
  cat("\nClass:", c, "\n")
  
  class_edges <- subset(edges, class == c)
  class_nodes <- subset(nodes, class == c)
  
  invalid_ids <- setdiff(unique(class_edges$target), unique(class_nodes$name))
  
  if (length(invalid_ids) == 0) {
    cat("All nominations in this class refer to existing nodes.\n")
  } else {
    cat("IDs nominated but not present in original data:\n")
    print(invalid_ids)
    
    temp <- data.frame(
      name   = invalid_ids,
      class  = rep(c, length(invalid_ids)),
      school = rep(unique(class_nodes$school)[1], length(invalid_ids))
    )
    invalid_all <- rbind(invalid_all, temp)
  }
}


```

```{r}
# Combine invalid nodes with the original node list
nodes_extended <- rbind(nodes, invalid_all)

```

### Plots and metrics

```{r}

par(mar = c(1, 1, 2, 1))

network_summary <- data.frame(
  class = character(),
  n_nodes = numeric(),
  n_edges = numeric(),
  n_nominators = numeric(),
  cohesion_capped = numeric(),
  avg_outdegree = numeric(),
  density_directed_raw = numeric(),   
  reciprocity = numeric(),
  transitivity = numeric(),
  n_components = numeric(),
  largest_component_size = numeric(),
  stringsAsFactors = FALSE
)

max_outdegree <- 5  # nomination cap

for (cls in classes) {
  edges_sub <- subset(edges, class == cls)
  nodes_sub <- subset(nodes_extended, class == cls)
  
  g <- graph_from_data_frame(
    d = edges_sub[, c("source", "target")],
    vertices = nodes_sub,
    directed = TRUE
  )
  
  n_nodes <- vcount(g)
  n_edges <- ecount(g)
  
  # Number of students who could nominate
  n_nominators <- nrow(subset(data_sn, class == cls))
  
  # Raw density 
  dens_raw <- edge_density(g, loops = FALSE)
  
  avg_outdeg <- ifelse(n_nominators > 0, n_edges / n_nominators, NA)
  capped_den <- ifelse(n_nominators > 0, avg_outdeg / max_outdegree, NA)
  
  rec <- reciprocity(g)
  trans <- transitivity(g, type = "global")
  
  comps <- components(g, mode = "weak")
  n_comp <- comps$no
  largest_comp <- max(comps$csize)
  
  network_summary <- rbind(network_summary, data.frame(
    class = cls,
    n_nodes = n_nodes,
    n_edges = n_edges,
    n_nominators = n_nominators,
    avg_outdegree = round(avg_outdeg, 3),
    cohesion_capped = round(capped_den, 3),
    density_directed_raw = round(dens_raw, 3),
    reciprocity = round(rec, 3),
    transitivity = round(trans, 3),
    n_components = n_comp,
    largest_component_size = largest_comp
  ))
  
  
  plot(
    g,
    main = paste("Directed nomination network – Class", cls),
    edge.width = 0.6,
    vertex.size = 14,
    vertex.label.cex = 0.7,
    layout = layout_with_fr
  )
}

print(network_summary)

```

### Network descriptives

Descriptives of each class to see how they compare against each other

```{r}

# Clean nominations column into numeric lists
data_sn$nominations_clean = lapply(data_sn$nom_like, function(x) {
  if (is.null(x) || all(is.na(x))) return(NA)
  as.numeric(unlist(str_extract_all(paste(x, collapse = " "), "\\d+")))
})

# Count number of nominations per subject
data_sn$n_nominations = sapply(data_sn$nominations_clean, function(x) {
  if (all(is.na(x))) 0 else length(x)
})

# Create summary data frame
class_summary = data.frame(
  class = classes,
  n_subjects = NA,
  total_nominations = NA,
  mean_nominations = NA,
  total_reciprocal_nomination = NA
)

# Loop through classes and compute descriptives
for (i in seq_along(classes)) {
  cls = classes[i]
  sub_df = data_sn[data_sn$class == cls, ]
  
  n_subjects = nrow(sub_df)
  total_nominations = sum(sub_df$n_nominations, na.rm = TRUE)
  mean_nominations = mean(sub_df$n_nominations, na.rm = TRUE)
  
  # Get reciprocal edge count from the already-created g_recip graph
  edges_sub = subset(edges, class == cls)
  nodes_sub = subset(nodes_extended, class == cls)
  g = graph_from_data_frame(
    d = edges_sub[, c("source", "target")],
    vertices = nodes_sub,
    directed = TRUE
  )
  g_recip = as.undirected(g, mode = "mutual")
  total_reciprocal = ecount(g_recip)
  
  class_summary[i, "n_subjects"] = n_subjects
  class_summary[i, "total_nominations"] = total_nominations
  class_summary[i, "mean_nominations"] = mean_nominations
  class_summary[i, "total_reciprocal_nomination"] = total_reciprocal
}

# View results
print(class_summary)

```

```{r}
network_overview = merge(class_summary, network_summary,
                     by = "class",
                     all = TRUE)
  
print(network_overview)
```

### Adjusting original dataset

```{r}
# Add susceptibility
data$susceptibility <- round(rowMeans(data[, all_items], na.rm = TRUE), 2)

# Impute missing susceptibility by class mean
class_means <- tapply(data$susceptibility, data$class, mean, na.rm = TRUE)

for (i in 1:nrow(data)) {
  if (is.na(data$susceptibility[i])) {
    cls <- as.character(data$class[i])
    data$susceptibility[i] <- class_means[cls]
  }
}

# Merge cohesion into main dataset
data <- merge(
  data,
  network_summary[, c("class", "cohesion_capped", "avg_outdegree")],
  by = "class",
  all.x = TRUE
)

# Center variables
data$avg_outdegree_c     <- as.numeric(scale(data$avg_outdegree, center = TRUE, scale = FALSE))
data$cohesion_capped_c   <- as.numeric(scale(data$cohesion_capped, center = TRUE, scale = FALSE))
data$susceptibility_c    <- as.numeric(scale(data$susceptibility, center = TRUE, scale = FALSE))

# Descriptives
summary(network_summary$cohesion_capped)

sd(network_summary$cohesion_capped, na.rm = TRUE)
cor.test(network_summary$n_nodes, network_summary$cohesion_capped)

# Save
saveRDS(
  data,
  here::here("data", "processed", "data2_incl_moderation.rds")
)


```


