positive_norm = "#59A14F",
negative_norm = "#E15759",
control       = "#4E79A7"
)) +
scale_y_continuous(
labels = scales::percent_format(accuracy = 1),
limits = c(0, 1),                     # start at 0%, cap at 100%
expand = expansion(mult = c(0, 0.02)) # remove bottom padding
) +
labs(
y = "Predicted Probability of High-Effort Choice",
x = "Block",
title = "Model-Based Interaction: Target × Group × Block"
) +
theme_bw(base_size = 13) +
theme(legend.position = "bottom",
strip.text = element_text(face = "bold"))
emmip(final_model, effort ~ reward, type = "response") # plot
emmip(emm_tg, group ~ target) # plot
emmip(final_model, group ~ block | target, type = "response") # plot
source(here::here("R","_common.R"), local = knitr::knit_global())
# --- 1. Import data ---
df_wide <- readRDS(here::here("data","processed","data2_incl_moderation.rds"))
head(df_wide)
# --- 2. Ensure factors ---
df_wide <- df_wide |>
mutate(
ppn = as.factor(ppn),
school = factor(school, levels = c(1, 2, 3),
labels = c("1_loc1", "1_loc2", "2")),
class = as.factor(class),
group = factor(group, levels = c(1, 2, 3),
labels = c("positive_norm", "negative_norm", "control"))
)
# Center new susceptibility and cohesion
df_wide <- df_wide |>
mutate(susceptibility_c = susceptibility - mean(susceptibility, na.rm = TRUE))
df_wide <- df_wide |>
mutate(cohesion_c = cohesion - mean(cohesion, na.rm = TRUE))
# --- 5. Identify trial columns ---
# Pattern matches trial names like: "1_SELF_2easy40" or "X2_CLIMATE_10hard90"
# (X)? = optional X prefix
# [12] = block number (1 or 2)
# (SELF|CLIMATE|OTHERS) = target type
# (2|6|10) = reward amount
# (easy|hard) = difficulty label (not extracted but part of pattern)
# (40|90) = effort level
trial_pattern <- "^(X)?[12]_(SELF|CLIMATE|OTHERS)_(2|6|10)(easy|hard)(40|90)$"
trial_cols <- names(select(df_wide, matches(trial_pattern)))
# --- 6. Reshape to long format ---
df_long <- df_wide |>
pivot_longer(
cols = all_of(trial_cols),
names_to = "trial",
values_to = "choice_raw"
) |>
mutate(
# Clean trial name (remove X prefix if present)
trial_clean = str_remove(trial, "^X"),
# Extract components from trial name
block_num   = as.integer(str_extract(trial_clean, "^[12]")),
target_raw  = str_extract(trial_clean, "(SELF|CLIMATE|OTHERS)"),
reward_num  = as.integer(str_extract(trial_clean, "(?<=_)\\d{1,2}(?=(easy|hard))")),
effort_raw  = as.integer(str_extract(trial_clean, "(40|90)$")),
# Create labeled factors with appropriate reference levels
block  = factor(block_num, levels = c(1, 2),
labels = c("pre", "post")),
target = factor(target_raw,
levels = c("SELF", "CLIMATE", "OTHERS"),
labels = c("self", "climate", "prosocial")),
effort = factor(effort_raw, levels = c(40, 90),
labels = c("40%", "90%")),
reward = factor(reward_num, levels = c(2, 6, 10),
labels = c("2 coins", "6 coins", "10 coins")),
reward_num_c = as.numeric(scale(reward_num, scale = FALSE)),
choice = case_when(
choice_raw == 1 ~ 1L,  # high-effort choice
choice_raw == 2 ~ 0L,  # low-effort choice
TRUE ~ NA_integer_
)
) |>
# Set reference levels for contrasts
mutate(
group = relevel(group, ref = "control"),
target = relevel(target, ref = "self"),
effort = relevel(effort, ref = "40%"),
block = relevel(block, ref = "pre")
) |>
select(ppn, school, class, group,
trial = trial_clean, block, target, reward, reward_num,
reward_num_c, effort, choice,
susceptibility, susceptibility_c, cohesion, cohesion_c)
# --- 7. Checks ---
# Check structure
glimpse(df_long)
# Balanced design?
table(df_long$group, df_long$block)
table(df_long$target, df_long$block)
# Missing data
colSums(is.na(df_long))
# Check outcome coding (should be mostly 1s, some 0s)
prop.table(table(df_long$choice))
# --- 8. Save data frames ---
# Save processed data (RDS preserves factors/classes)
saveRDS(df_long, here::here("data", "processed", "df_long.rds"))
saveRDS(df_wide, here::here("data", "processed", "df_wide.rds"))
knitr::opts_chunk$set(echo = TRUE)
install.packages("kableExtra")
library(lme4)
library(broom.mixed)   # tidy mixed-model outputs
library(dplyr)
library(tidyr)
library(ggplot2)
library(emmeans)       # marginal means (probabilities)
library(sjPlot)        # nice model tables
library(kableExtra)    # pretty tables
# Control
ctrl <- glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e6))
final_model <- glmer(
choice ~ target*group*block + reward*effort + school +
(1 + block | ppn),
data = df_long, family = binomial, control = ctrl
)
summary(final_model)
library(emmeans)
# Compute marginal means for target within each group
emm_tg <- emmeans(final_model, ~ target | group, type = "response")
emm_tg
pairs(emm_tg)
library(emmeans)
# Target x group interaction
# Compute marginal means for target within each group
emm_tg <- emmeans(final_model, ~ target | group, type = "response")
emm_tg
print(pairs(emm_tg))
# target x group x block interaction (non significant)
emm_tgb <- emmeans(final_model, ~ target | group * block, type = "response")
print(pairs(emm_tgb))
texreg::knitreg(list(final_model),
single.row = TRUE)
# Estimated marginal means on response scale
emm_re <- emmeans(final_model, ~ reward * effort, type = "response")
library(emmeans)
# Reward x effort interaction
# EMMs on response scale
emm_re <- emmeans(final_model, ~ reward * effort, type = "response")
# (A) Compare reward levels within each effort level
pairs_re_within_effort <- pairs(emm_re, by = "effort", adjust = "holm")
pairs_re_within_effort
# (B) Compare effort levels within each reward level
pairs_re_within_reward <- pairs(emm_re, by = "reward", adjust = "holm")
pairs_re_within_reward
# Target x group interaction
# EMMs per target within each group
emm_tg <- emmeans(final_model, ~ target | group, type = "response")
emm_tg
# Pairwise target comparisons within each group (Holm-corrected)
pairs_tg <- pairs(emm_tg, by = "group", adjust = "holm")
pairs_tg
# target x group x block interaction (non significant)
emm_tgb <- emmeans(final_model, ~ target | group * block, type = "response")
# Pairwise target comparisons within each group × block cell (Holm per cell)
pairs_tgb <- pairs(emm_tgb, by = c("group", "block"), adjust = "holm")
pairs_tgb
mod_model <- glmmTMB(
choice ~ target*group*block + reward*effort + school +
susceptibility_c*group + cohesion_c +
(1 + block | ppn),
data = df_long, family = binomial
)
library(glmmTMB)
mod_model <- glmmTMB(
choice ~ target*group*block + reward*effort + school +
susceptibility_c*group + cohesion_c +
(1 + block | ppn),
data = df_long, family = binomial
)
summary(mod_model)
texreg::knitreg(list(mod_model),
single.row = TRUE)
summary(mod_model)
# EMMs of group across susceptibility values (response scale)
emm_sus_g <- emmeans(mod_model, ~ group | susceptibility_c, at = at_list, type = "response")
# EMMs of group across susceptibility values (response scale)
emm_sus_g <- emmeans(mod_model, ~ group | susceptibility_c, type = "response")
emm_sus_g
pairs_sus_g
# Pairwise group comparisons at each susceptibility value (Holm)
pairs_sus_g <- pairs(emm_sus_g, by = "susceptibility_c", adjust = "holm")
pairs_sus_g
# emmeans — lines at representative values (faceted)
emmip(emm_sus_g, group ~ susceptibility_c, CIs = TRUE) +
labs(title = "Group differences across Susceptibility (EMMs)", x = "Susceptibility (rep. values)", y = "Estimated P(choice = 1)") +
theme_minimal(base_size = 12)
# emmeans — lines at representative values (faceted)
emmip(emm_sus_g, group ~ susceptibility_c, type = "response")
source(here::here("R","_common.R"), local = knitr::knit_global())
# Load processed data written by 1_dataprep
df_wide <- readRDS(here::here("data","processed","df_wide.rds"))
df_long <- readRDS(here::here("data","processed","df_long.rds"))
# Contrasts
options(contrasts = c("contr.sum", "contr.poly"))
# Control
ctrl <- glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e6))
emmip(final_mod_model, group ~ susceptibility_c,
at = list(susceptibility_c = seq(-2, 2, by = 0.5)),
type = "response") +
labs(title = "Group × Susceptibility", x = "Susceptibility (centered)", y = "Predicted probability") +
theme_minimal() # plot
emmip(mod_model, group ~ susceptibility_c,
at = list(susceptibility_c = seq(-2, 2, by = 0.5)),
type = "response") +
labs(title = "Group × Susceptibility", x = "Susceptibility (centered)", y = "Predicted probability") +
theme_minimal() # plot
# EMMs of group across susceptibility values (response scale)
emm_sus_g <- emmeans(mod_model, ~ susceptibility_c  | group , type = "response")
emm_sus_g
# Pairwise group comparisons at each susceptibility value (Holm)
pairs_sus_g <- pairs(emm_sus_g, by = "susceptibility_c", adjust = "holm")
pairs_sus_g
# emmeans — lines at representative values (faceted)
emmip(emm_sus_g, group ~ susceptibility_c, type = "response")
mod_model <- glmmTMB(
choice ~ target*group*block + reward*effort + school +
susceptibility_c*target*group*block + cohesion_c +
(1 + block | ppn),
data = df_long, family = binomial
)
summary(mod_model)
print(pairs_tgb)
emmip(final_model, effort ~ reward, type = "response") +
labs(title = "Reward × Effort", x = "Reward", y = "Estimated probability")
# target x group
emmip(final_model, group ~ target, type = "response") +
labs(title = "Target × Group", x = "Target", y = "Estimated probability")
emmip(final_model, group ~ target | block, type = "response") +
labs(title = "Target × Group × Block", x = "Target", y = "Estimated probability")
emmip(final_model, group ~ block | target, type = "response") +
labs(title = "Target × Group × Block", x = "Target", y = "Estimated probability")
mod_model <- glmmTMB(
choice ~ target*group*block + reward*effort + school +
susceptibility_c*group + cohesion_c +
(1 + block | ppn),
data = df_long, family = binomial
)
mod_model <- glmmTMB(
choice ~ target*group*block + reward*effort + school +
susceptibility_c*group + cohesion_c +
(1 + block | ppn),
data = df_long, family = binomial
)
summary(mod_model)
# emmeans — lines at representative values (faceted)
# Lines = group, x = susceptibility (continuous)
emmip(final_model, group ~ susceptibility_c,
at = list(susceptibility_c = seq(-2, 2, by = 0.5)),
CIs = TRUE, type = "response") +
labs(title = "Group × Susceptibility",
x = "Susceptibility (centered)", y = "Estimated probability")
# emmeans — lines at representative values (faceted)
emmip(final_model, group ~ susceptibility_c,
CIs = TRUE, type = "response") +
labs(title = "Group × Susceptibility",
x = "Susceptibility (centered)",
y = "Estimated probability")
# emmeans — lines at representative values (faceted)
emmip(mod_model, group ~ susceptibility_c, type = "response") +
labs(title = "Group × Susceptibility",
x = "Susceptibility (centered)",
y = "Estimated probability")
# Reward x effort interaction
# EMMs on response scale
emm_re <- emmeans(final_model, ~ reward * effort, type = "response")
# (A) Compare reward levels within each effort level
pairs_re_within_effort <- pairs(emm_re, by = "effort", adjust = "holm")
print(pairs_re_within_effort)
# (B) Compare effort levels within each reward level
pairs_re_within_reward <- pairs(emm_re, by = "reward", adjust = "holm")
print(pairs_re_within_reward)
# Target x group interaction
# EMMs per target within each group
emm_tg <- emmeans(final_model, ~ target | group, type = "response")
print(emm_tg)
# Pairwise target comparisons within each group (Holm-corrected)
pairs_tg <- pairs(emm_tg, by = "group", adjust = "holm")
print(pairs_tg)
# target x group x block interaction (non significant)
emm_tgb <- emmeans(final_model, ~ target | group * block, type = "response")
# Pairwise target comparisons within each group × block cell (Holm per cell)
pairs_tgb <- pairs(emm_tgb, by = c("group", "block"), adjust = "holm")
print(pairs_tgb)
summary(final_model)
final_model <- glmer(
choice ~ target*group*block + reward*effort + school +
(1 + block | ppn),
data = df_long, family = binomial, control = ctrl
)
car::Anova(final_model, type = 3)
summary(final_model)
# Contrasts
options(contrasts = c("contr.sum", "contr.poly"))
# --- 6. Reshape to long format ---
df_long <- df_wide |>
pivot_longer(
cols = all_of(trial_cols),
names_to = "trial",
values_to = "choice_raw"
) |>
mutate(
# Clean trial name (remove X prefix if present)
trial_clean = str_remove(trial, "^X"),
# Extract components from trial name
block_num   = as.integer(str_extract(trial_clean, "^[12]")),
target_raw  = str_extract(trial_clean, "(SELF|CLIMATE|OTHERS)"),
reward_num  = as.integer(str_extract(trial_clean, "(?<=_)\\d{1,2}(?=(easy|hard))")),
effort_raw  = as.integer(str_extract(trial_clean, "(40|90)$")),
# Create labeled factors with appropriate reference levels
block  = factor(block_num, levels = c(1, 2),
labels = c("pre", "post")),
target = factor(target_raw,
levels = c("SELF", "CLIMATE", "OTHERS"),
labels = c("self", "climate", "prosocial")),
effort = factor(effort_raw, levels = c(40, 90),
labels = c("40%", "90%")),
reward = factor(reward_num, levels = c(2, 6, 10),
labels = c("2 coins", "6 coins", "10 coins")),
reward_num_c = as.numeric(scale(reward_num, scale = FALSE)),
choice = case_when(
choice_raw == 1 ~ 1L,  # high-effort choice
choice_raw == 2 ~ 0L,  # low-effort choice
TRUE ~ NA_integer_
)
) |>
# Set reference levels for contrasts
mutate(
group = relevel(group, ref = "control"),
target = relevel(target, ref = "self"),
effort = relevel(effort, ref = "40%"),
block = relevel(block, ref = "pre")
) |>
select(ppn, school, class, group,
trial = trial_clean, block, target, reward, reward_num,
reward_num_c, effort, choice,
susceptibility, susceptibility_c, cohesion, cohesion_c)
# Contrasts
options(contrasts = c("contr.sum", "contr.poly"))
final_model <- glmer(
choice ~ target*group*block + reward*effort + school +
(1 + block | ppn),
data = df_long, family = binomial, control = ctrl
)
final_model <- glmer(
choice ~ target*group*block + reward*effort + school +
(1 + block | ppn),
data = df_long, family = binomial, control = ctrl
)
summary(final_model)
texreg::knitreg(list(final_model),
single.row = TRUE)
levels(df_long$target)
df_long$target
levels(df_long$target)
levels(df_long$group)
source(here::here("R","_common.R"), local = knitr::knit_global())
# Load processed data written by 1_dataprep
df_wide <- readRDS(here::here("data","processed","df_wide.rds"))
df_long <- readRDS(here::here("data","processed","df_long.rds"))
# Contrasts
options(contrasts = c("contr.sum", "contr.poly"))
# Control
ctrl <- glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e6))
final_model <- glmer(
choice ~ target*group*block + reward*effort + school +
(1 + block | ppn),
data = df_long, family = binomial, control = ctrl
)
final_model <- glmer(
choice ~ target*group*block + reward*effort + school +
(1 + block | ppn),
data = df_long, family = binomial, control = ctrl
)
summary(final_model)
source(here::here("R","_common.R"), local = knitr::knit_global())
# Load processed data written by 1_dataprep
df_wide <- readRDS(here::here("data","processed","df_wide.rds"))
df_long <- readRDS(here::here("data","processed","df_long.rds"))
# Contrasts
options(contrasts = c("contr.sum", "contr.poly"))
# Control
ctrl <- glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e6))
# Step 1: Test whether classroom random intercept is needed
m1 <- glmer(
choice ~ target*group*block + reward*effort + school +
(1 | ppn) + (1 | class),
data = df_long, family = binomial, control = ctrl
)
m1_simpler <- glmer(
choice ~ target*group*block + reward*effort + school +
(1 | ppn),
data = df_long, family = binomial, control = ctrl
)
# Compare models
print(anova(m1_simpler, m1, test = "Chisq"))
print(isSingular(m1))
print(VarCorr(m1))
# Step 2: Add random slope for Block
m2 <- glmer(
choice ~ target*group*block + reward*effort + school +
(1 + block | ppn),
data = df_long, family = binomial, control = ctrl
)
# Compare models
print(anova(m1_simpler, m2, test = "Chisq")) # model 2 is better
cat("\nIs m2 singular? ", isSingular(m2), "\n")
print(VarCorr(m2))
# Choose final model
final_model <- m2
print(summary(final_model))
# Fixed Effects
print(Anova(final_model, type = 3))
# --- Reward x effort ---
emm_re <- emmeans(final_model, ~ reward * effort, type = "response")
print(summary(contrast(emm_re, "pairwise", by = "effort", adjust = "holm"),
infer = TRUE, type = "response"))
print(summary(contrast(emm_re, "pairwise", by = "reward", adjust = "holm"),
infer = TRUE, type = "response"))
emmip(final_model, effort ~ reward, CIs = TRUE, type = "response") # plot
# --- Target x group ---
emm_tg <- emmeans(final_model, ~ target * group, type = "response")
print(summary(contrast(emm_tg, "pairwise", by = "group", adjust = "holm"),
infer = TRUE, type = "response"))
print(summary(contrast(emm_tg, "pairwise", by = "target", adjust = "holm"),
infer = TRUE, type = "response"))
emmip(emm_tg, group ~ target, CIs = TRUE) # plot
# Block x Target x Group (Difference-in-Differences)
# Get all EMMs
emm_all <- emmeans(final_model, ~ target * group * block, type = "response")
print(emm_all)
# Calculate pre-post differences
emm_by_block <- emmeans(final_model, ~ block | target * group, type = "response")
post_pre <- contrast(emm_by_block, method = "revpairwise")
print(post_pre)
# Compare pre-post changes between groups (difference-in-differences)
did_groups <- pairs(post_pre, by = "target", adjust = "holm")
print(did_groups)
# Focus on climate trials
climate_delta <- subset(post_pre, target == "climate")
print(climate_delta)
print(pairs(climate_delta, adjust = "holm"))
emmip(final_model, group ~ block | target, CIs = TRUE, type = "response") # plot
set.seed(123)
res <- simulateResiduals(final_model, n = 1000)
plot(res)
testUniformity(res)
testDispersion(res)
testZeroInflation(res)
testOutliers(res)
print(VarCorr(final_model))
print(performance::icc(final_model))
print(performance::check_collinearity(final_model))
# Baseline model (no moderators)
m_baseline <- glmmTMB(
choice ~ target*group*block + reward*effort + school +
(1 + block | ppn),
data = df_long, family = binomial
)
source(here::here("R","_common.R"), local = knitr::knit_global())
# Load processed data written by 1_dataprep
df_wide <- readRDS(here::here("data","processed","df_wide.rds"))
df_long <- readRDS(here::here("data","processed","df_long.rds"))
# Contrasts
options(contrasts = c("contr.sum", "contr.poly"))
# Control
ctrl <- glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e6))
View(ctrl)
View(df_wide)
View(df_long)
View(df_wide)
View(df_long)
View(df_wide)
edges <- df_wide |>
mutate(nom_like = coalesce(nom_like, "")) |>
mutate(nominations = str_split(nom_like, ",")) |>
unnest(nominations) |>
mutate(
from = as.character(ppn),
to = str_trim(nominations)
) |>
filter(to != "") |>
select(class, from, to)
edges
dges <- df_wide |>
mutate(nom_like = coalesce(nom_like, "")) |>
mutate(nominations = str_split(nom_like, ",")) |>
unnest(nominations) |>
mutate(
contrib = as.character(ppn),
occurences = str_trim(nominations)
) |>
filter(to != "") |>
select(class, from, to)
# Convert the nom_like column into an edge list
edges <- df_wide |>
mutate(nom_like = coalesce(nom_like, "")) |>
mutate(nominations = str_split(nom_like, ",")) |>
unnest(nominations) |>
mutate(
contrib = as.character(ppn),
occurences = str_trim(nominations)
) |>
filter(to != "") |>
select(class, contrib, occurences)
